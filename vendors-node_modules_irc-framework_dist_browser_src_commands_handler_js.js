/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkpesterchum"] = self["webpackChunkpesterchum"] || []).push([["vendors-node_modules_irc-framework_dist_browser_src_commands_handler_js"],{

/***/ "./node_modules/irc-framework/dist/browser/src/commands/command.js":
/*!*************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/command.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.date.to-string */ \"./node_modules/core-js/modules/es.date.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.define-property */ \"./node_modules/core-js/modules/es.object.define-property.js\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = {\n  clone: __webpack_require__(/*! lodash/clone */ \"./node_modules/lodash/clone.js\")\n};\nvar numberRegex = /^[0-9.]{1,}$/;\n\nmodule.exports = /*#__PURE__*/function () {\n  function IrcCommand(command, data) {\n    _classCallCheck(this, IrcCommand);\n\n    this.command = command += '';\n    this.params = _.clone(data.params);\n    this.tags = _.clone(data.tags);\n    this.prefix = data.prefix;\n    this.nick = data.nick;\n    this.ident = data.ident;\n    this.hostname = data.hostname;\n  }\n\n  _createClass(IrcCommand, [{\n    key: \"getTag\",\n    value: function getTag(tag_name) {\n      return this.tags[tag_name.toLowerCase()];\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function getServerTime() {\n      var timeTag = this.getTag('time'); // Explicitly return undefined if theres no time\n      // or the value is an empty string\n\n      if (!timeTag) {\n        return undefined;\n      } // If parsing fails for some odd reason, also fallback to\n      // undefined, instead of returning NaN\n\n\n      var time = Date.parse(timeTag) || undefined; // Support for znc.in/server-time unix timestamps\n\n      if (!time && numberRegex.test(timeTag)) {\n        return new Date(timeTag * 1000).getTime();\n      }\n\n      return time;\n    }\n  }]);\n\n  return IrcCommand;\n}();\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/command.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handler.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol */ \"./node_modules/core-js/modules/es.symbol.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.description */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.iterator */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.concat */ \"./node_modules/core-js/modules/es.array.concat.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.find */ \"./node_modules/core-js/modules/es.array.find.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.reduce */ \"./node_modules/core-js/modules/es.array.reduce.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.to-string */ \"./node_modules/core-js/modules/es.date.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.create */ \"./node_modules/core-js/modules/es.object.create.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.define-property */ \"./node_modules/core-js/modules/es.object.define-property.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of */ \"./node_modules/core-js/modules/es.object.get-prototype-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ \"./node_modules/core-js/modules/es.object.set-prototype-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.to-string */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.reflect.construct */ \"./node_modules/core-js/modules/es.reflect.construct.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.to-string */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar _ = {\n  reduce: __webpack_require__(/*! lodash/reduce */ \"./node_modules/lodash/reduce.js\"),\n  find: __webpack_require__(/*! lodash/find */ \"./node_modules/lodash/find.js\"),\n  uniq: __webpack_require__(/*! lodash/uniq */ \"./node_modules/lodash/uniq.js\")\n};\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n\nvar irc_numerics = __webpack_require__(/*! ./numerics */ \"./node_modules/irc-framework/dist/browser/src/commands/numerics.js\");\n\nvar IrcCommand = __webpack_require__(/*! ./command */ \"./node_modules/irc-framework/dist/browser/src/commands/command.js\");\n\nmodule.exports = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(IrcCommandHandler, _EventEmitter);\n\n  var _super = _createSuper(IrcCommandHandler);\n\n  function IrcCommandHandler(connection, network_info) {\n    var _this;\n\n    _classCallCheck(this, IrcCommandHandler);\n\n    _this = _super.call(this); // Adds an 'all' event to .emit()\n\n    _this.addAllEventName();\n\n    _this.connection = connection;\n    _this.network = network_info;\n    _this.handlers = [];\n    _this.request_extra_caps = [];\n\n    _this.resetCache();\n\n    __webpack_require__(/*! ./handlers/registration */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/registration.js\")(_assertThisInitialized(_this));\n\n    __webpack_require__(/*! ./handlers/channel */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/channel.js\")(_assertThisInitialized(_this));\n\n    __webpack_require__(/*! ./handlers/user */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/user.js\")(_assertThisInitialized(_this));\n\n    __webpack_require__(/*! ./handlers/messaging */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/messaging.js\")(_assertThisInitialized(_this));\n\n    __webpack_require__(/*! ./handlers/misc */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/misc.js\")(_assertThisInitialized(_this));\n\n    __webpack_require__(/*! ./handlers/generics */ \"./node_modules/irc-framework/dist/browser/src/commands/handlers/generics.js\")(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(IrcCommandHandler, [{\n    key: \"dispatch\",\n    value: function dispatch(message) {\n      var irc_command = new IrcCommand(message.command.toUpperCase(), message); // Batched commands will be collected and executed as a transaction\n\n      var batch_id = irc_command.getTag('batch');\n\n      if (batch_id) {\n        var cache_key = 'batch.' + batch_id;\n\n        if (this.hasCache(cache_key)) {\n          var cache = this.cache(cache_key);\n          cache.commands.push(irc_command);\n        } else {// If we don't have this batch ID in cache, it either means that the\n          // server hasn't sent the starting batch command or that the server\n          // has already sent the end batch command.\n        }\n      } else {\n        this.executeCommand(irc_command);\n      }\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(irc_command) {\n      var command_name = irc_command.command; // Check if we have a numeric->command name- mapping for this command\n\n      if (irc_numerics[irc_command.command.toUpperCase()]) {\n        command_name = irc_numerics[irc_command.command.toUpperCase()];\n      }\n\n      if (this.handlers[command_name]) {\n        this.handlers[command_name](irc_command, this);\n      } else {\n        this.emitUnknownCommand(irc_command);\n      }\n    }\n  }, {\n    key: \"requestExtraCaps\",\n    value: function requestExtraCaps(cap) {\n      this.request_extra_caps = _.uniq(this.request_extra_caps.concat(cap));\n    }\n  }, {\n    key: \"addHandler\",\n    value: function addHandler(command, handler) {\n      if (typeof handler !== 'function') {\n        return false;\n      }\n\n      this.handlers[command] = handler;\n    }\n  }, {\n    key: \"emitUnknownCommand\",\n    value: function emitUnknownCommand(command) {\n      this.emit('unknown command', command);\n    } // Adds an 'all' event to .emit()\n\n  }, {\n    key: \"addAllEventName\",\n    value: function addAllEventName() {\n      var original_emit = this.emit;\n\n      this.emit = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        original_emit.apply(this, ['all'].concat(args));\n        original_emit.apply(this, args);\n      };\n    }\n    /**\n    * Convert a mode string such as '+k pass', or '-i' to a readable\n    * format.\n    * [ { mode: '+k', param: 'pass' } ]\n    * [ { mode: '-i', param: null } ]\n    */\n\n  }, {\n    key: \"parseModeList\",\n    value: function parseModeList(mode_string, mode_params) {\n      var chanmodes = this.network.options.CHANMODES || [];\n      var prefixes = this.network.options.PREFIX || [];\n      var always_param = (chanmodes[0] || '').concat(chanmodes[1] || '');\n      var modes = [];\n      var i;\n      var j;\n      var add;\n\n      if (!mode_string) {\n        return modes;\n      }\n\n      prefixes = _.reduce(prefixes, function (list, prefix) {\n        list.push(prefix.mode);\n        return list;\n      }, []);\n      always_param = always_param.split('').concat(prefixes);\n\n      var hasParam = function hasParam(mode, isAdd) {\n        var matchMode = function matchMode(m) {\n          return m === mode;\n        };\n\n        if (_.find(always_param, matchMode)) {\n          return true;\n        }\n\n        if (isAdd && _.find((chanmodes[2] || '').split(''), matchMode)) {\n          return true;\n        }\n\n        return false;\n      };\n\n      j = 0;\n\n      for (i = 0; i < mode_string.length; i++) {\n        switch (mode_string[i]) {\n          case '+':\n            add = true;\n            break;\n\n          case '-':\n            add = false;\n            break;\n\n          default:\n            if (hasParam(mode_string[i], add)) {\n              modes.push({\n                mode: (add ? '+' : '-') + mode_string[i],\n                param: mode_params[j]\n              });\n              j++;\n            } else {\n              modes.push({\n                mode: (add ? '+' : '-') + mode_string[i],\n                param: null\n              });\n            }\n\n        }\n      }\n\n      return modes;\n    }\n    /**\n     * Cache object for commands buffering data before emitting them\n     * eg.\n     * var cache = this.cache('userlist');\n     * cache.nicks = [];\n     * cache.destroy();\n     */\n\n  }, {\n    key: \"cache\",\n    value: function cache(id) {\n      var cache = this._caches[id];\n\n      if (!cache) {\n        var destroyCacheFn = function destroyCacheFn(cacheToDestroy, idInCache) {\n          return function () {\n            delete cacheToDestroy[idInCache];\n          };\n        }; // We don't want the destoryCache to be iterable\n\n\n        cache = Object.defineProperty({}, 'destroy', {\n          enumerable: false,\n          configurable: false,\n          value: destroyCacheFn(this._caches, id)\n        });\n        this._caches[id] = cache;\n      }\n\n      return cache;\n    }\n  }, {\n    key: \"hasCache\",\n    value: function hasCache(id) {\n      return this._caches && Object.prototype.hasOwnProperty.call(this._caches, id);\n    }\n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      this._caches = Object.create(null);\n    }\n  }]);\n\n  return IrcCommandHandler;\n}(EventEmitter);\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handler.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handlers/channel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handlers/channel.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.parse-int */ \"./node_modules/core-js/modules/es.parse-int.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\nvar _ = {\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\")\n};\n\nvar Helpers = __webpack_require__(/*! ../../helpers */ \"./node_modules/irc-framework/dist/browser/src/helpers.js\");\n\nvar handlers = {\n  RPL_CHANNELMODEIS: function RPL_CHANNELMODEIS(command, handler) {\n    var channel = command.params[1];\n    var raw_modes = command.params[2];\n    var raw_params = command.params.slice(3);\n    var modes = handler.parseModeList(raw_modes, raw_params);\n    handler.emit('channel info', {\n      channel: channel,\n      modes: modes,\n      raw_modes: raw_modes,\n      raw_params: raw_params,\n      tags: command.tags\n    });\n  },\n  RPL_CREATIONTIME: function RPL_CREATIONTIME(command, handler) {\n    var channel = command.params[1];\n    handler.emit('channel info', {\n      channel: channel,\n      created_at: parseInt(command.params[2], 10),\n      tags: command.tags\n    });\n  },\n  RPL_CHANNEL_URL: function RPL_CHANNEL_URL(command, handler) {\n    var channel = command.params[1];\n    handler.emit('channel info', {\n      channel: channel,\n      url: command.params[command.params.length - 1],\n      tags: command.tags\n    });\n  },\n  RPL_NAMEREPLY: function RPL_NAMEREPLY(command, handler) {\n    var members = command.params[command.params.length - 1].split(' ');\n    var cache = handler.cache('names.' + command.params[2]);\n\n    if (!cache.members) {\n      cache.members = [];\n    }\n\n    _.each(members, function (member) {\n      if (!member) {\n        return;\n      }\n\n      var j = 0;\n      var modes = [];\n      var user = null; // If we have prefixes, strip them from the nick and keep them separate\n\n      if (handler.network.options.PREFIX) {\n        for (j = 0; j < handler.network.options.PREFIX.length; j++) {\n          if (member[0] === handler.network.options.PREFIX[j].symbol) {\n            modes.push(handler.network.options.PREFIX[j].mode);\n            member = member.substring(1);\n          }\n        }\n      } // We may have a full user mask if the userhost-in-names CAP is enabled\n\n\n      user = Helpers.parseMask(member);\n      cache.members.push({\n        nick: user.nick,\n        ident: user.user,\n        hostname: user.host,\n        modes: modes,\n        tags: command.tags\n      });\n    });\n  },\n  RPL_ENDOFNAMES: function RPL_ENDOFNAMES(command, handler) {\n    var cache = handler.cache('names.' + command.params[1]);\n    handler.emit('userlist', {\n      channel: command.params[1],\n      users: cache.members || []\n    });\n    cache.destroy();\n  },\n  RPL_INVITELIST: function RPL_INVITELIST(command, handler) {\n    var cache = handler.cache('inviteList.' + command.params[1]);\n\n    if (!cache.invites) {\n      cache.invites = [];\n    }\n\n    cache.invites.push({\n      channel: command.params[1],\n      invited: command.params[2],\n      invited_by: command.params[3],\n      invited_at: command.params[4],\n      tags: command.tags\n    });\n  },\n  RPL_ENDOFINVITELIST: function RPL_ENDOFINVITELIST(command, handler) {\n    var cache = handler.cache('inviteList.' + command.params[1]);\n    handler.emit('inviteList', {\n      channel: command.params[1],\n      invites: cache.invites || []\n    });\n    cache.destroy();\n  },\n  RPL_BANLIST: function RPL_BANLIST(command, handler) {\n    var cache = handler.cache('banlist.' + command.params[1]);\n\n    if (!cache.bans) {\n      cache.bans = [];\n    }\n\n    cache.bans.push({\n      channel: command.params[1],\n      banned: command.params[2],\n      banned_by: command.params[3],\n      banned_at: command.params[4],\n      tags: command.tags\n    });\n  },\n  RPL_ENDOFBANLIST: function RPL_ENDOFBANLIST(command, handler) {\n    var cache = handler.cache('banlist.' + command.params[1]);\n    handler.emit('banlist', {\n      channel: command.params[1],\n      bans: cache.bans || []\n    });\n    cache.destroy();\n  },\n  RPL_TOPIC: function RPL_TOPIC(command, handler) {\n    handler.emit('topic', {\n      channel: command.params[1],\n      topic: command.params[command.params.length - 1],\n      tags: command.tags\n    });\n  },\n  RPL_NOTOPIC: function RPL_NOTOPIC(command, handler) {\n    handler.emit('topic', {\n      channel: command.params[1],\n      topic: '',\n      tags: command.tags\n    });\n  },\n  RPL_TOPICWHOTIME: function RPL_TOPICWHOTIME(command, handler) {\n    var parsed = Helpers.parseMask(command.params[2]);\n    handler.emit('topicsetby', {\n      nick: parsed.nick,\n      ident: parsed.user,\n      hostname: parsed.host,\n      channel: command.params[1],\n      when: command.params[3],\n      tags: command.tags\n    });\n  },\n  JOIN: function JOIN(command, handler) {\n    var channel;\n    var gecos_idx = 1;\n    var data = {};\n\n    if (typeof command.params[0] === 'string' && command.params[0] !== '') {\n      channel = command.params[0];\n    }\n\n    if (handler.network.cap.isEnabled('extended-join')) {\n      data.account = command.params[1] === '*' ? false : command.params[1];\n      gecos_idx = 2;\n    }\n\n    data.nick = command.nick;\n    data.ident = command.ident;\n    data.hostname = command.hostname;\n    data.gecos = command.params[gecos_idx] || '';\n    data.channel = channel;\n    data.time = command.getServerTime();\n    data.tags = command.tags;\n    handler.emit('join', data);\n  },\n  PART: function PART(command, handler) {\n    var time = command.getServerTime();\n    handler.emit('part', {\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      channel: command.params[0],\n      message: command.params[command.params.length - 1] || '',\n      time: time,\n      tags: command.tags\n    });\n  },\n  KICK: function KICK(command, handler) {\n    var time = command.getServerTime();\n    handler.emit('kick', {\n      kicked: command.params[1],\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      channel: command.params[0],\n      message: command.params[command.params.length - 1] || '',\n      time: time,\n      tags: command.tags\n    });\n  },\n  QUIT: function QUIT(command, handler) {\n    var time = command.getServerTime();\n    handler.emit('quit', {\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      message: command.params[command.params.length - 1] || '',\n      time: time,\n      tags: command.tags\n    });\n  },\n  TOPIC: function TOPIC(command, handler) {\n    // If we don't have an associated channel, no need to continue\n    if (!command.params[0]) {\n      return;\n    } // Check if we have a server-time\n\n\n    var time = command.getServerTime();\n    var channel = command.params[0];\n    var topic = command.params[command.params.length - 1] || '';\n    handler.emit('topic', {\n      nick: command.nick,\n      channel: channel,\n      topic: topic,\n      time: time,\n      tags: command.tags\n    });\n  },\n  INVITE: function INVITE(command, handler) {\n    var time = command.getServerTime();\n    handler.emit('invite', {\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      invited: command.params[0],\n      channel: command.params[1],\n      time: time,\n      tags: command.tags\n    });\n  },\n  RPL_INVITING: function RPL_INVITING(command, handler) {\n    handler.emit('invited', {\n      nick: command.params[0],\n      channel: command.params[1],\n      tags: command.tags\n    });\n  }\n};\n\nmodule.exports = function AddCommandHandlers(command_controller) {\n  _.each(handlers, function (handler, handler_command) {\n    command_controller.addHandler(handler_command, handler);\n  });\n};\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handlers/channel.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handlers/generics.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handlers/generics.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n\nGeneric IRC events. Simply passing selected IRC params into javascript objects\n\nExample\n    ERROR: {              IRC Command to match\n        event: 'error',   Event name to trigger on the cleint instance\n        reason: -1        Property on the triggered event, and which IRC param to should contain\n    },\n*/\n\n__webpack_require__(/*! core-js/modules/es.array.for-each */ \"./node_modules/core-js/modules/es.array.for-each.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.keys */ \"./node_modules/core-js/modules/es.object.keys.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n\nvar generics = {\n  ERROR: {\n    event: 'irc error',\n    error: 'irc',\n    reason: -1\n  },\n  ERR_PASSWDMISMATCH: {\n    event: 'irc error',\n    error: 'password_mismatch'\n  },\n  ERR_LINKCHANNEL: {\n    event: 'channel_redirect',\n    from: 1,\n    to: 2\n  },\n  ERR_NOSUCHNICK: {\n    event: 'irc error',\n    error: 'no_such_nick',\n    nick: 1,\n    reason: -1\n  },\n  ERR_CANNOTSENDTOCHAN: {\n    event: 'irc error',\n    error: 'cannot_send_to_channel',\n    channel: 1,\n    reason: -1\n  },\n  ERR_TOOMANYCHANNELS: {\n    event: 'irc error',\n    error: 'too_many_channels',\n    channel: 1,\n    reason: -1\n  },\n  ERR_USERNOTINCHANNEL: {\n    event: 'irc error',\n    error: 'user_not_in_channel',\n    nick: 0,\n    channel: 1,\n    reason: -1\n  },\n  ERR_NOTONCHANNEL: {\n    event: 'irc error',\n    error: 'not_on_channel',\n    channel: 1,\n    reason: -1\n  },\n  ERR_USERONCHANNEL: {\n    event: 'irc error',\n    error: 'user_on_channel',\n    nick: 1,\n    channel: 2\n  },\n  ERR_CHANNELISFULL: {\n    event: 'irc error',\n    error: 'channel_is_full',\n    channel: 1,\n    reason: -1\n  },\n  ERR_INVITEONLYCHAN: {\n    event: 'irc error',\n    error: 'invite_only_channel',\n    channel: 1,\n    reason: -1\n  },\n  ERR_BANNEDFROMCHAN: {\n    event: 'irc error',\n    error: 'banned_from_channel',\n    channel: 1,\n    reason: -1\n  },\n  ERR_BADCHANNELKEY: {\n    event: 'irc error',\n    error: 'bad_channel_key',\n    channel: 1,\n    reason: -1\n  },\n  ERR_CHANOPRIVSNEEDED: {\n    event: 'irc error',\n    error: 'chanop_privs_needed',\n    channel: 1,\n    reason: -1\n  },\n  ERR_UNKNOWNCOMMAND: {\n    event: 'irc error',\n    error: 'unknown_command',\n    command: 1,\n    reason: -1\n  }\n};\nvar generic_keys = Object.keys(generics);\n\nmodule.exports = function AddCommandHandlers(command_controller) {\n  generic_keys.forEach(function (generic_command) {\n    var generic = generics[generic_command];\n    command_controller.addHandler(generic_command, function (command, handler) {\n      var event_obj = {};\n      var event_keys = Object.keys(generic);\n      var val;\n\n      for (var i = 0; i < event_keys.length; i++) {\n        if (event_keys[i] === 'event') {\n          continue;\n        }\n\n        val = generic[event_keys[i]];\n\n        if (typeof val === 'string') {\n          event_obj[event_keys[i]] = val;\n        } else if (val >= 0) {\n          event_obj[event_keys[i]] = command.params[val];\n        } else if (val < 0) {\n          event_obj[event_keys[i]] = command.params[command.params.length + val];\n        }\n      }\n\n      if (event_obj.channel) {\n        // Extract the group from any errors targetted towards channels with a statusmsg prefix\n        // Eg. @#channel\n        var parsed = handler.network.extractTargetGroup(event_obj.channel);\n\n        if (parsed) {\n          event_obj.channel = parsed.target;\n          event_obj.target_group = parsed.target_group;\n        }\n      }\n\n      handler.emit(generic.event, event_obj);\n    });\n  });\n};\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handlers/generics.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handlers/messaging.js":
/*!************************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handlers/messaging.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\nvar _ = {\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\"),\n  find: __webpack_require__(/*! lodash/find */ \"./node_modules/lodash/find.js\")\n};\n\nvar util = __webpack_require__(/*! util */ \"?0bed\");\n\nvar handlers = {\n  NOTICE: function NOTICE(command, handler) {\n    var time = command.getServerTime();\n    var message = command.params[command.params.length - 1];\n    var target = command.params[0];\n    var target_group;\n\n    if (message.charAt(0) === '\\x01' && message.charAt(message.length - 1) === '\\x01') {\n      // It's a CTCP response\n      handler.emit('ctcp response', {\n        nick: command.nick,\n        ident: command.ident,\n        hostname: command.hostname,\n        target: target,\n        type: (message.substring(1, message.length - 1).split(' ') || [null])[0],\n        message: message.substring(1, message.length - 1),\n        time: time,\n        tags: command.tags\n      });\n    } else {\n      var parsed_target = handler.network.extractTargetGroup(target);\n\n      if (parsed_target) {\n        target = parsed_target.target;\n        target_group = parsed_target.target_group;\n      }\n\n      handler.emit('notice', {\n        from_server: !command.nick,\n        nick: command.nick,\n        ident: command.ident,\n        hostname: command.hostname,\n        target: target,\n        group: target_group,\n        message: message,\n        tags: command.tags,\n        time: time,\n        account: command.getTag('account')\n      });\n    }\n  },\n  PRIVMSG: function PRIVMSG(command, handler) {\n    var time = command.getServerTime();\n    var message = command.params[command.params.length - 1];\n    var target = command.params[0];\n    var target_group;\n    var parsed_target = handler.network.extractTargetGroup(target);\n\n    if (parsed_target) {\n      target = parsed_target.target;\n      target_group = parsed_target.target_group;\n    }\n\n    if (message.charAt(0) === '\\x01' && message.charAt(message.length - 1) === '\\x01') {\n      // CTCP request\n      var ctcp_command = message.slice(1, -1).split(' ')[0].toUpperCase();\n\n      if (ctcp_command === 'ACTION') {\n        handler.emit('action', {\n          from_server: !command.nick,\n          nick: command.nick,\n          ident: command.ident,\n          hostname: command.hostname,\n          target: target,\n          group: target_group,\n          message: message.substring(8, message.length - 1),\n          tags: command.tags,\n          time: time,\n          account: command.getTag('account')\n        });\n      } else if (ctcp_command === 'VERSION' && handler.connection.options.version) {\n        handler.connection.write(util.format('NOTICE %s :\\x01VERSION %s\\x01', command.nick, handler.connection.options.version));\n      } else {\n        handler.emit('ctcp request', {\n          from_server: !command.nick,\n          nick: command.nick,\n          ident: command.ident,\n          hostname: command.hostname,\n          target: target,\n          group: target_group,\n          type: ctcp_command || null,\n          message: message.substring(1, message.length - 1),\n          time: time,\n          account: command.getTag('account'),\n          tags: command.tags\n        });\n      }\n    } else {\n      handler.emit('privmsg', {\n        from_server: !command.nick,\n        nick: command.nick,\n        ident: command.ident,\n        hostname: command.hostname,\n        target: target,\n        group: target_group,\n        message: message,\n        tags: command.tags,\n        time: time,\n        account: command.getTag('account')\n      });\n    }\n  },\n  TAGMSG: function TAGMSG(command, handler) {\n    var time = command.getServerTime();\n    var target = command.params[0];\n    handler.emit('tagmsg', {\n      from_server: !command.nick,\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      target: target,\n      tags: command.tags,\n      time: time\n    });\n  },\n  RPL_WALLOPS: function RPL_WALLOPS(command, handler) {\n    handler.emit('wallops', {\n      from_server: false,\n      nick: command.nick,\n      ident: command.ident,\n      hostname: command.hostname,\n      message: command.params[command.params.length - 1],\n      account: command.getTag('account'),\n      tags: command.tags\n    });\n  }\n};\n\nmodule.exports = function AddCommandHandlers(command_controller) {\n  _.each(handlers, function (handler, handler_command) {\n    command_controller.addHandler(handler_command, handler);\n  });\n};\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handlers/messaging.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handlers/misc.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handlers/misc.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.array.filter */ \"./node_modules/core-js/modules/es.array.filter.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.for-each */ \"./node_modules/core-js/modules/es.array.for-each.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.index-of */ \"./node_modules/core-js/modules/es.array.index-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.join */ \"./node_modules/core-js/modules/es.array.join.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.map */ \"./node_modules/core-js/modules/es.array.map.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.splice */ \"./node_modules/core-js/modules/es.array.splice.js\");\n\n__webpack_require__(/*! core-js/modules/es.parse-int */ \"./node_modules/core-js/modules/es.parse-int.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n\nvar _ = {\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\"),\n  clone: __webpack_require__(/*! lodash/clone */ \"./node_modules/lodash/clone.js\"),\n  map: __webpack_require__(/*! lodash/map */ \"./node_modules/lodash/map.js\")\n};\nvar handlers = {\n  RPL_LISTSTART: function RPL_LISTSTART(command, handler) {\n    var cache = getChanListCache(handler);\n    cache.channels = [];\n    handler.emit('channel list start');\n  },\n  RPL_LISTEND: function RPL_LISTEND(command, handler) {\n    var cache = getChanListCache(handler);\n\n    if (cache.channels.length) {\n      handler.emit('channel list', cache.channels);\n      cache.channels = [];\n    }\n\n    cache.destroy();\n    handler.emit('channel list end');\n  },\n  RPL_LIST: function RPL_LIST(command, handler) {\n    var cache = getChanListCache(handler);\n    cache.channels.push({\n      channel: command.params[1],\n      num_users: parseInt(command.params[2], 10),\n      topic: command.params[3] || '',\n      tags: command.tags\n    });\n\n    if (cache.channels.length >= 50) {\n      handler.emit('channel list', cache.channels);\n      cache.channels = [];\n    }\n  },\n  RPL_MOTD: function RPL_MOTD(command, handler) {\n    var cache = handler.cache('motd');\n    cache.motd += command.params[command.params.length - 1] + '\\n';\n  },\n  RPL_MOTDSTART: function RPL_MOTDSTART(command, handler) {\n    var cache = handler.cache('motd');\n    cache.motd = '';\n  },\n  RPL_ENDOFMOTD: function RPL_ENDOFMOTD(command, handler) {\n    var cache = handler.cache('motd');\n    handler.emit('motd', {\n      motd: cache.motd,\n      tags: command.tags\n    });\n    cache.destroy();\n  },\n  ERR_NOMOTD: function ERR_NOMOTD(command, handler) {\n    var params = _.clone(command.params);\n\n    params.shift();\n    handler.emit('motd', {\n      error: command.params[command.params.length - 1],\n      tags: command.tags\n    });\n  },\n  RPL_WHOREPLY: function RPL_WHOREPLY(command, handler) {\n    var cache = handler.cache('who');\n\n    if (!cache.members) {\n      cache.members = [];\n    }\n\n    var params = command.params; // G = Gone, H = Here\n\n    var is_away = params[6][0].toUpperCase() === 'G'; // get user channel modes\n\n    var net_prefixes = handler.network.options.PREFIX; // filter PREFIX array against the prefix's in who reply returning matched PREFIX objects\n\n    var chan_prefixes = net_prefixes.filter(function (f) {\n      return params[6].indexOf(f.symbol) > -1;\n    }); // use _.map to return an array of mode strings from matched PREFIX objects\n\n    var chan_modes = _.map(chan_prefixes, 'mode');\n\n    var hops_away = 0;\n    var realname = params[7]; // The realname should be in the format of \"<num hops> <real name>\"\n\n    var space_idx = realname.indexOf(' ');\n\n    if (space_idx > -1) {\n      hops_away = parseInt(realname.substr(0, space_idx), 10);\n      realname = realname.substr(space_idx + 1);\n    }\n\n    cache.members.push({\n      nick: params[5],\n      ident: params[2],\n      hostname: params[3],\n      server: params[4],\n      real_name: realname,\n      away: is_away,\n      num_hops_away: hops_away,\n      channel: params[1],\n      channel_modes: chan_modes,\n      tags: command.tags\n    });\n  },\n  RPL_WHOSPCRPL: function RPL_WHOSPCRPL(command, handler) {\n    var cache = handler.cache('who');\n\n    if (!cache.members) {\n      cache.members = [];\n    }\n\n    var params = command.params; // G = Gone, H = Here\n\n    var is_away = params[6][0].toUpperCase() === 'G'; // get user channel modes\n\n    var net_prefixes = handler.network.options.PREFIX; // filter PREFIX array against the prefix's in who reply returning matched PREFIX objects\n\n    var chan_prefixes = net_prefixes.filter(function (f) {\n      return params[6].indexOf(f.symbol) > -1;\n    }); // use _.map to return an array of mode strings from matched PREFIX objects\n\n    var chan_modes = _.map(chan_prefixes, 'mode'); // Some ircd's use n/a for no level, unify them all to 0 for no level\n\n\n    var op_level = !/^[0-9]+$/.test(params[9]) ? 0 : parseInt(params[9], 10);\n    cache.members.push({\n      nick: params[5],\n      ident: params[2],\n      hostname: params[3],\n      server: params[4],\n      op_level: op_level,\n      real_name: params[10],\n      account: params[8] === '0' ? '' : params[8],\n      away: is_away,\n      num_hops_away: parseInt(params[7], 10),\n      channel: params[1],\n      channel_modes: chan_modes,\n      tags: command.tags\n    });\n  },\n  RPL_ENDOFWHO: function RPL_ENDOFWHO(command, handler) {\n    var cache = handler.cache('who');\n    handler.emit('wholist', {\n      target: command.params[1],\n      users: cache.members || []\n    });\n    cache.destroy();\n  },\n  PING: function PING(command, handler) {\n    handler.connection.write('PONG ' + command.params[command.params.length - 1]);\n  },\n  PONG: function PONG(command, handler) {\n    var time = command.getServerTime();\n\n    if (time) {\n      handler.network.addServerTimeOffset(time);\n    }\n\n    handler.emit('pong', {\n      message: command.params[1],\n      time: time,\n      tags: command.tags\n    });\n  },\n  MODE: function MODE(command, handler) {\n    // Check if we have a server-time\n    var time = command.getServerTime(); // Get a JSON representation of the modes\n\n    var raw_modes = command.params[1];\n    var raw_params = command.params.slice(2);\n    var modes = handler.parseModeList(raw_modes, raw_params);\n    handler.emit('mode', {\n      target: command.params[0],\n      nick: command.nick || command.prefix || '',\n      modes: modes,\n      time: time,\n      raw_modes: raw_modes,\n      raw_params: raw_params,\n      tags: command.tags\n    });\n  },\n  RPL_LINKS: function RPL_LINKS(command, handler) {\n    var cache = handler.cache('links');\n    cache.links = cache.links || [];\n    cache.links.push({\n      address: command.params[1],\n      access_via: command.params[2],\n      hops: parseInt(command.params[3].split(' ')[0]),\n      description: command.params[3].split(' ').splice(1).join(' '),\n      tags: command.tags\n    });\n  },\n  RPL_ENDOFLINKS: function RPL_ENDOFLINKS(command, handler) {\n    var cache = handler.cache('links');\n    handler.emit('server links', {\n      links: cache.links\n    });\n    cache.destroy();\n  },\n  RPL_INFO: function RPL_INFO(command, handler) {\n    var cache = handler.cache('info');\n\n    if (!cache.info) {\n      cache.info = '';\n    }\n\n    cache.info += command.params[command.params.length - 1] + '\\n';\n  },\n  RPL_ENDOFINFO: function RPL_ENDOFINFO(command, handler) {\n    var cache = handler.cache('info');\n    handler.emit('info', {\n      info: cache.info,\n      tags: command.tags\n    });\n    cache.destroy();\n  },\n  RPL_HELPSTART: function RPL_HELPSTART(command, handler) {\n    var cache = handler.cache('help');\n    cache.help = command.params[command.params.length - 1] + '\\n';\n  },\n  RPL_HELPTXT: function RPL_HELPTXT(command, handler) {\n    var cache = handler.cache('help');\n    cache.help += command.params[command.params.length - 1] + '\\n';\n  },\n  RPL_ENDOFHELP: function RPL_ENDOFHELP(command, handler) {\n    var cache = handler.cache('help');\n    handler.emit('help', {\n      help: cache.help,\n      tags: command.tags\n    });\n    cache.destroy();\n  },\n  BATCH: function BATCH(command, handler) {\n    var batch_start = command.params[0].substr(0, 1) === '+';\n    var batch_id = command.params[0].substr(1);\n    var cache_key = 'batch.' + batch_id;\n\n    if (!batch_id) {\n      return;\n    }\n\n    if (batch_start) {\n      var _cache = handler.cache(cache_key);\n\n      _cache.commands = [];\n      _cache.type = command.params[1];\n      _cache.params = command.params.slice(2);\n      return;\n    }\n\n    if (!handler.hasCache(cache_key)) {\n      // If we don't have this batch ID in cache, it either means that the\n      // server hasn't sent the starting batch command or that the server\n      // has already sent the end batch command.\n      return;\n    }\n\n    var cache = handler.cache(cache_key);\n    var emit_obj = {\n      id: batch_id,\n      type: cache.type,\n      params: cache.params,\n      commands: cache.commands\n    }; // Destroy the cache object before executing each command. If one\n    // errors out then we don't have the cache object stuck in memory.\n\n    cache.destroy();\n    handler.emit('batch start', emit_obj);\n    handler.emit('batch start ' + emit_obj.type, emit_obj);\n    emit_obj.commands.forEach(function (c) {\n      return handler.executeCommand(c);\n    });\n    handler.emit('batch end', emit_obj);\n    handler.emit('batch end ' + emit_obj.type, emit_obj);\n  }\n};\n\nmodule.exports = function AddCommandHandlers(command_controller) {\n  _.each(handlers, function (handler, handler_command) {\n    command_controller.addHandler(handler_command, handler);\n  });\n};\n\nfunction getChanListCache(handler) {\n  var cache = handler.cache('chanlist'); // fix some IRC networks\n\n  if (!cache.channels) {\n    cache.channels = [];\n  }\n\n  return cache;\n}\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handlers/misc.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/commands/handlers/registration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/commands/handlers/registration.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.array.concat */ \"./node_modules/core-js/modules/es.array.concat.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.index-of */ \"./node_modules/core-js/modules/es.array.index-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.join */ \"./node_modules/core-js/modules/es.array.join.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.map */ \"./node_modules/core-js/modules/es.array.map.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.now */ \"./node_modules/core-js/modules/es.date.now.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.to-string */ \"./node_modules/core-js/modules/es.date.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.name */ \"./node_modules/core-js/modules/es.function.name.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.create */ \"./node_modules/core-js/modules/es.object.create.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.to-string */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.to-string */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.match */ \"./node_modules/core-js/modules/es.string.match.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.replace */ \"./node_modules/core-js/modules/es.string.replace.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\nvar Helpers = __webpack_require__(/*! ../../helpers */ \"./node_modules/irc-framework/dist/browser/src/helpers.js\");\n\nvar _ = {\n  intersection: __webpack_require__(/*! lodash/intersection */ \"./node_modules/lodash/intersection.js\"),\n  difference: __webpack_require__(/*! lodash/difference */ \"./node_modules/lodash/difference.js\"),\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\"),\n  uniq: __webpack_require__(/*! lodash/uniq */ \"./node_modules/lodash/uniq.js\")\n};\nvar handlers = {\n  RPL_WELCOME: function RPL_WELCOME(command, handler) {\n    var nick = command.params[0]; // Get the server name so we know which messages are by the server in future\n\n    handler.network.server = command.prefix;\n    handler.network.cap.negotiating = false; // We can't use the time given here as ZNC actually replays the time when it first connects\n    // to an IRC server, not now(). Send a PING so that we can get a reliable time from PONG\n\n    if (handler.network.cap.isEnabled('server-time')) {\n      // Ping to try get a server-time in its response as soon as possible\n      handler.connection.write('PING ' + Date.now());\n    }\n\n    handler.emit('registered', {\n      nick: nick,\n      tags: command.tags\n    });\n  },\n  RPL_YOURHOST: function RPL_YOURHOST(command, handler) {\n    // Your host is ircd.network.org, running version InspIRCd-2.0\n    var param = command.params[1] || '';\n    var m = param.match(/running version (.*)$/);\n\n    if (!m) {\n      handler.network.ircd = '';\n    } else {\n      handler.network.ircd = m[1];\n    }\n  },\n  RPL_ISUPPORT: function RPL_ISUPPORT(command, handler) {\n    var options = command.params;\n    var i;\n    var option;\n    var matches;\n    var j;\n\n    for (i = 1; i < options.length; i++) {\n      option = Helpers.splitOnce(options[i], '=');\n      option[0] = option[0].toUpperCase();\n      handler.network.options[option[0]] = typeof option[1] !== 'undefined' ? option[1] : true;\n\n      if (option[0] === 'PREFIX') {\n        matches = /\\(([^)]*)\\)(.*)/.exec(option[1]);\n\n        if (matches && matches.length === 3) {\n          handler.network.options.PREFIX = [];\n\n          for (j = 0; j < matches[2].length; j++) {\n            handler.network.options.PREFIX.push({\n              symbol: matches[2].charAt(j),\n              mode: matches[1].charAt(j)\n            });\n          }\n        }\n      } else if (option[0] === 'CHANTYPES') {\n        handler.network.options.CHANTYPES = handler.network.options.CHANTYPES.split('');\n      } else if (option[0] === 'STATUSMSG') {\n        handler.network.options.STATUSMSG = handler.network.options.STATUSMSG.split('');\n      } else if (option[0] === 'CHANMODES') {\n        handler.network.options.CHANMODES = option[1].split(',');\n      } else if (option[0] === 'NETWORK') {\n        handler.network.name = option[1];\n      } else if (option[0] === 'NAMESX' && !handler.network.cap.isEnabled('multi-prefix')) {\n        // Tell the server to send us all user modes in NAMES reply, not just\n        // the highest one\n        handler.connection.write('PROTOCTL NAMESX');\n      }\n    }\n\n    handler.emit('server options', {\n      options: handler.network.options,\n      cap: handler.network.cap.enabled,\n      tags: command.tags\n    });\n  },\n  CAP: function CAP(command, handler) {\n    var request_caps = [];\n    var capability_values = Object.create(null); // TODO: capability modifiers\n    // i.e. - for disable, ~ for requires ACK, = for sticky\n\n    var capabilities = command.params[command.params.length - 1].replace(/(?:^| )[-~=]/, '').split(' ').map(function (cap) {\n      // CAPs in 3.2 may be in the form of CAP=VAL. So seperate those out\n      var sep = cap.indexOf('=');\n\n      if (sep === -1) {\n        capability_values[cap] = '';\n        return cap;\n      }\n\n      var cap_name = cap.substr(0, sep);\n      var cap_value = cap.substr(sep + 1);\n      capability_values[cap_name] = cap_value;\n      return cap_name;\n    }); // Which capabilities we want to enable\n\n    var want = ['cap-notify', 'batch', 'multi-prefix', 'message-tags', 'draft/message-tags-0.2', 'away-notify', 'invite-notify', 'account-notify', 'account-tag', 'server-time', 'userhost-in-names', 'extended-join', 'znc.in/server-time-iso', 'znc.in/server-time']; // Optional CAPs depending on settings\n\n    var saslAuth = getSaslAuth(handler);\n\n    if (saslAuth || handler.connection.options.sasl_mechanism === 'EXTERNAL') {\n      want.push('sasl');\n    }\n\n    if (handler.connection.options.enable_chghost) {\n      want.push('chghost');\n    }\n\n    if (handler.connection.options.enable_setname) {\n      want.push('setname');\n    }\n\n    if (handler.connection.options.enable_echomessage) {\n      want.push('echo-message');\n    }\n\n    want = _.uniq(want.concat(handler.request_extra_caps));\n\n    switch (command.params[1]) {\n      case 'LS':\n        // Compute which of the available capabilities we want and request them\n        request_caps = _.intersection(capabilities, want);\n\n        if (request_caps.length > 0) {\n          handler.network.cap.requested = handler.network.cap.requested.concat(request_caps);\n        } // CAP 3.2 multline support. Only send our CAP requests on the last CAP LS\n        // line which will not have * set for params[2]\n\n\n        if (command.params[2] !== '*') {\n          if (handler.network.cap.requested.length > 0) {\n            handler.network.cap.negotiating = true;\n            handler.connection.write('CAP REQ :' + handler.network.cap.requested.join(' '));\n          } else {\n            handler.connection.write('CAP END');\n            handler.network.cap.negotiating = false;\n          }\n        }\n\n        break;\n\n      case 'ACK':\n        if (capabilities.length > 0) {\n          // Update list of enabled capabilities\n          handler.network.cap.enabled = _.uniq(handler.network.cap.enabled.concat(capabilities)); // Update list of capabilities we would like to have but that aren't enabled\n\n          handler.network.cap.requested = _.difference(handler.network.cap.requested, capabilities);\n        }\n\n        if (handler.network.cap.negotiating) {\n          if (handler.network.cap.isEnabled('sasl')) {\n            if (typeof handler.connection.options.sasl_mechanism === 'string') {\n              handler.connection.write('AUTHENTICATE ' + handler.connection.options.sasl_mechanism);\n            } else {\n              handler.connection.write('AUTHENTICATE PLAIN');\n            }\n          } else if (handler.network.cap.requested.length === 0) {\n            // If all of our requested CAPs have been handled, end CAP negotiation\n            handler.connection.write('CAP END');\n            handler.network.cap.negotiating = false;\n          }\n        }\n\n        break;\n\n      case 'NAK':\n        if (capabilities.length > 0) {\n          handler.network.cap.requested = _.difference(handler.network.cap.requested, capabilities);\n        } // If all of our requested CAPs have been handled, end CAP negotiation\n\n\n        if (handler.network.cap.negotiating && handler.network.cap.requested.length === 0) {\n          handler.connection.write('CAP END');\n          handler.network.cap.negotiating = false;\n        }\n\n        break;\n\n      case 'LIST':\n        // should we do anything here?\n        break;\n\n      case 'NEW':\n        // Request any new CAPs that we want but haven't already enabled\n        request_caps = [];\n\n        for (var i = 0; i < capabilities.length; i++) {\n          var cap = capabilities[i];\n\n          if (want.indexOf(cap) > -1 && request_caps.indexOf(cap) === -1 && !handler.network.cap.isEnabled(cap)) {\n            handler.network.cap.requested.push(cap);\n            request_caps.push(cap);\n          }\n        }\n\n        handler.connection.write('CAP REQ :' + request_caps.join(' '));\n        break;\n\n      case 'DEL':\n        // Update list of enabled capabilities\n        handler.network.cap.enabled = _.difference(handler.network.cap.enabled, capabilities);\n        break;\n    }\n\n    handler.emit('cap ' + command.params[1].toLowerCase(), {\n      command: command.params[1],\n      capabilities: capability_values\n    });\n  },\n  AUTHENTICATE: function AUTHENTICATE(command, handler) {\n    if (command.params[0] !== '+') {\n      if (handler.network.cap.negotiating) {\n        handler.connection.write('CAP END');\n        handler.network.cap.negotiating = false;\n      }\n\n      return;\n    } // Send blank authenticate for EXTERNAL mechanism\n\n\n    if (handler.connection.options.sasl_mechanism === 'EXTERNAL') {\n      handler.connection.write('AUTHENTICATE +');\n      return;\n    }\n\n    var saslAuth = getSaslAuth(handler);\n    var auth_str = saslAuth.account + '\\0' + saslAuth.account + '\\0' + saslAuth.password;\n    var b = Buffer.from(auth_str, 'utf8');\n    var b64 = b.toString('base64');\n\n    while (b64.length >= 400) {\n      handler.connection.write('AUTHENTICATE ' + b64.slice(0, 399));\n      b64 = b64.slice(399);\n    }\n\n    if (b64.length > 0) {\n      handler.connection.write('AUTHENTICATE ' + b64);\n    } else {\n      handler.connection.write('AUTHENTICATE +');\n    }\n  },\n  RPL_LOGGEDIN: function RPL_LOGGEDIN(command, handler) {\n    if (handler.network.cap.negotiating === true) {\n      handler.connection.write('CAP END');\n      handler.network.cap.negotiating = false;\n    }\n\n    var mask = Helpers.parseMask(command.params[1]); // Check if we have a server-time\n\n    var time = command.getServerTime();\n    handler.emit('loggedin', {\n      nick: command.params[0],\n      ident: mask.user,\n      hostname: mask.host,\n      account: command.params[2],\n      time: time,\n      tags: command.tags\n    });\n    handler.emit('account', {\n      nick: command.params[0],\n      ident: mask.user,\n      hostname: mask.host,\n      account: command.params[2],\n      time: time,\n      tags: command.tags\n    });\n  },\n  RPL_LOGGEDOUT: function RPL_LOGGEDOUT(command, handler) {\n    var mask = Helpers.parseMask(command.params[1]); // Check if we have a server-time\n\n    var time = command.getServerTime();\n    handler.emit('loggedout', {\n      nick: command.params[0],\n      ident: mask.user,\n      hostname: mask.host,\n      account: false,\n      time: time,\n      tags: command.tags\n    });\n    handler.emit('account', {\n      nick: command.params[0],\n      ident: mask.user,\n      hostname: mask.host,\n      account: false,\n      time: time,\n      tags: command.tags\n    });\n  },\n  RPL_SASLLOGGEDIN: function RPL_SASLLOGGEDIN(command, handler) {\n    if (handler.network.cap.negotiating === true) {\n      handler.connection.write('CAP END');\n      handler.network.cap.negotiating = false;\n    }\n  },\n  ERR_SASLNOTAUTHORISED: function ERR_SASLNOTAUTHORISED(command, handler) {\n    if (handler.network.cap.negotiating) {\n      handler.connection.write('CAP END');\n      handler.network.cap.negotiating = false;\n    }\n  },\n  ERR_SASLABORTED: function ERR_SASLABORTED(command, handler) {\n    if (handler.network.cap.negotiating) {\n      handler.connection.write('CAP END');\n      handler.network.cap.negotiating = false;\n    }\n  },\n  ERR_SASLALREADYAUTHED: function ERR_SASLALREADYAUTHED(command, handler) {// noop\n  }\n};\n/**\n * Only use the nick+password combo if an account has not been specifically given.\n * If an account:{account,password} has been given, use it for SASL auth.\n */\n\nfunction getSaslAuth(handler) {\n  var options = handler.connection.options;\n\n  if (options.account && options.account.account) {\n    // An account username has been given, use it for SASL auth\n    return {\n      account: options.account.account,\n      password: options.account.password || ''\n    };\n  } else if (options.account) {\n    // An account object existed but without auth credentials\n    return null;\n  } else if (options.password) {\n    // No account credentials found but we have a server password. Also use it for SASL\n    // for ease of use\n    return {\n      account: options.nick,\n      password: options.password\n    };\n  }\n\n  return null;\n}\n\nmodule.exports = function AddCommandHandlers(command_controller) {\n  _.each(handlers, function (handler, handler_command) {\n    command_controller.addHandler(handler_command, handler);\n  });\n};\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/commands/handlers/registration.js?");

/***/ })

}]);