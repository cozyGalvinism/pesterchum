/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkpesterchum"] = self["webpackChunkpesterchum"] || []).push([["vendors-node_modules_fast-text-encoding_text_min_js-node_modules_irc-framework_dist_browser_s-c460a8"],{

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty,\n    prefix = '~';\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\n\nfunction Events() {} //\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\n\n\nif (Object.create) {\n  Events.prototype = Object.create(null); //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n\n  if (!new Events().__proto__) prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\n\n\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\n\n\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once),\n      evt = prefix ? prefix + event : event;\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n  return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\n\n\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\n\n\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\n\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = [],\n      events,\n      name;\n  if (this._eventsCount === 0) return names;\n\n  for (name in events = this._events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\n\n\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event,\n      handlers = this._events[evt];\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\n\n\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event,\n      listeners = this._events[evt];\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\n\n\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n  if (!this._events[evt]) return false;\n  var listeners = this._events[evt],\n      len = arguments.length,\n      args,\n      i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1:\n        return listeners.fn.call(listeners.context), true;\n\n      case 2:\n        return listeners.fn.call(listeners.context, a1), true;\n\n      case 3:\n        return listeners.fn.call(listeners.context, a1, a2), true;\n\n      case 4:\n        return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\n      case 5:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\n      case 6:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len - 1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length,\n        j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1:\n          listeners[i].fn.call(listeners[i].context);\n          break;\n\n        case 2:\n          listeners[i].fn.call(listeners[i].context, a1);\n          break;\n\n        case 3:\n          listeners[i].fn.call(listeners[i].context, a1, a2);\n          break;\n\n        case 4:\n          listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n          break;\n\n        default:\n          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n  if (!this._events[evt]) return this;\n\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n        events.push(listeners[i]);\n      }\n    } //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n\n\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n  }\n\n  return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n}; //\n// Alias methods names because people roll like that.\n//\n\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on; //\n// Expose the prefix.\n//\n\nEventEmitter.prefixed = prefix; //\n// Allow `EventEmitter` to be imported as module namespace.\n//\n\nEventEmitter.EventEmitter = EventEmitter; //\n// Expose the module.\n//\n\nif (true) {\n  module.exports = EventEmitter;\n}\n\n//# sourceURL=webpack://pesterchum/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/fast-text-encoding/text.min.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-text-encoding/text.min.js ***!
  \*****************************************************/
/***/ (function() {

eval("(function (l) {\n  function m() {}\n\n  function k(a, c) {\n    a = void 0 === a ? \"utf-8\" : a;\n    c = void 0 === c ? {\n      fatal: !1\n    } : c;\n    if (-1 === r.indexOf(a.toLowerCase())) throw new RangeError(\"Failed to construct 'TextDecoder': The encoding label provided ('\" + a + \"') is invalid.\");\n    if (c.fatal) throw Error(\"Failed to construct 'TextDecoder': the 'fatal' option is unsupported.\");\n  }\n\n  function t(a) {\n    return Buffer.from(a.buffer, a.byteOffset, a.byteLength).toString(\"utf-8\");\n  }\n\n  function u(a) {\n    var c = URL.createObjectURL(new Blob([a], {\n      type: \"text/plain;charset=UTF-8\"\n    }));\n\n    try {\n      var f = new XMLHttpRequest();\n      f.open(\"GET\", c, !1);\n      f.send();\n      return f.responseText;\n    } catch (e) {\n      return q(a);\n    } finally {\n      URL.revokeObjectURL(c);\n    }\n  }\n\n  function q(a) {\n    for (var c = 0, f = Math.min(65536, a.length + 1), e = new Uint16Array(f), h = [], d = 0;;) {\n      var b = c < a.length;\n\n      if (!b || d >= f - 1) {\n        h.push(String.fromCharCode.apply(null, e.subarray(0, d)));\n        if (!b) return h.join(\"\");\n        a = a.subarray(c);\n        d = c = 0;\n      }\n\n      b = a[c++];\n      if (0 === (b & 128)) e[d++] = b;else if (192 === (b & 224)) {\n        var g = a[c++] & 63;\n        e[d++] = (b & 31) << 6 | g;\n      } else if (224 === (b & 240)) {\n        g = a[c++] & 63;\n        var n = a[c++] & 63;\n        e[d++] = (b & 31) << 12 | g << 6 | n;\n      } else if (240 === (b & 248)) {\n        g = a[c++] & 63;\n        n = a[c++] & 63;\n        var v = a[c++] & 63;\n        b = (b & 7) << 18 | g << 12 | n << 6 | v;\n        65535 < b && (b -= 65536, e[d++] = b >>> 10 & 1023 | 55296, b = 56320 | b & 1023);\n        e[d++] = b;\n      }\n    }\n  }\n\n  if (l.TextEncoder && l.TextDecoder) return !1;\n  var r = [\"utf-8\", \"utf8\", \"unicode-1-1-utf-8\"];\n  Object.defineProperty(m.prototype, \"encoding\", {\n    value: \"utf-8\"\n  });\n\n  m.prototype.encode = function (a, c) {\n    c = void 0 === c ? {\n      stream: !1\n    } : c;\n    if (c.stream) throw Error(\"Failed to encode: the 'stream' option is unsupported.\");\n    c = 0;\n\n    for (var f = a.length, e = 0, h = Math.max(32, f + (f >>> 1) + 7), d = new Uint8Array(h >>> 3 << 3); c < f;) {\n      var b = a.charCodeAt(c++);\n\n      if (55296 <= b && 56319 >= b) {\n        if (c < f) {\n          var g = a.charCodeAt(c);\n          56320 === (g & 64512) && (++c, b = ((b & 1023) << 10) + (g & 1023) + 65536);\n        }\n\n        if (55296 <= b && 56319 >= b) continue;\n      }\n\n      e + 4 > d.length && (h += 8, h *= 1 + c / a.length * 2, h = h >>> 3 << 3, g = new Uint8Array(h), g.set(d), d = g);\n      if (0 === (b & 4294967168)) d[e++] = b;else {\n        if (0 === (b & 4294965248)) d[e++] = b >>> 6 & 31 | 192;else if (0 === (b & 4294901760)) d[e++] = b >>> 12 & 15 | 224, d[e++] = b >>> 6 & 63 | 128;else if (0 === (b & 4292870144)) d[e++] = b >>> 18 & 7 | 240, d[e++] = b >>> 12 & 63 | 128, d[e++] = b >>> 6 & 63 | 128;else continue;\n        d[e++] = b & 63 | 128;\n      }\n    }\n\n    return d.slice ? d.slice(0, e) : d.subarray(0, e);\n  };\n\n  Object.defineProperty(k.prototype, \"encoding\", {\n    value: \"utf-8\"\n  });\n  Object.defineProperty(k.prototype, \"fatal\", {\n    value: !1\n  });\n  Object.defineProperty(k.prototype, \"ignoreBOM\", {\n    value: !1\n  });\n  var p = q;\n  \"function\" === typeof Buffer && Buffer.from ? p = t : \"function\" === typeof Blob && \"function\" === typeof URL && \"function\" === typeof URL.createObjectURL && (p = u);\n\n  k.prototype.decode = function (a, c) {\n    c = void 0 === c ? {\n      stream: !1\n    } : c;\n    if (c.stream) throw Error(\"Failed to decode: the 'stream' option is unsupported.\");\n    a = a instanceof Uint8Array ? a : a.buffer instanceof ArrayBuffer ? new Uint8Array(a.buffer) : new Uint8Array(a);\n    return p(a);\n  };\n\n  l.TextEncoder = m;\n  l.TextDecoder = k;\n})(\"undefined\" !== typeof window ? window : \"undefined\" !== typeof global ? global : this);\n\n//# sourceURL=webpack://pesterchum/./node_modules/fast-text-encoding/text.min.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/channel.js":
/*!****************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/channel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol */ \"./node_modules/core-js/modules/es.symbol.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.description */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.iterator */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.filter */ \"./node_modules/core-js/modules/es.array.filter.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.find */ \"./node_modules/core-js/modules/es.array.find.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.join */ \"./node_modules/core-js/modules/es.array.join.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.to-string */ \"./node_modules/core-js/modules/es.date.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.bind */ \"./node_modules/core-js/modules/es.function.bind.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.name */ \"./node_modules/core-js/modules/es.function.name.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.define-property */ \"./node_modules/core-js/modules/es.object.define-property.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.to-string */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.to-string */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = {\n  partial: __webpack_require__(/*! lodash/partial */ \"./node_modules/lodash/partial.js\"),\n  filter: __webpack_require__(/*! lodash/filter */ \"./node_modules/lodash/filter.js\"),\n  find: __webpack_require__(/*! lodash/find */ \"./node_modules/lodash/find.js\"),\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\"),\n  pull: __webpack_require__(/*! lodash/pull */ \"./node_modules/lodash/pull.js\"),\n  extend: __webpack_require__(/*! lodash/extend */ \"./node_modules/lodash/extend.js\")\n};\n\nvar DuplexStream = __webpack_require__(/*! stream */ \"?cc48\").Duplex;\n\nmodule.exports = /*#__PURE__*/function () {\n  function IrcChannel(irc_client, channel_name, key) {\n    var _this = this;\n\n    _classCallCheck(this, IrcChannel);\n\n    this.irc_client = irc_client;\n    this.name = channel_name; // TODO: Proxy channel related events from irc_bot to this instance\n\n    this.say = _.partial(irc_client.say.bind(irc_client), channel_name);\n    this.notice = _.partial(irc_client.notice.bind(irc_client), channel_name); // this.action = _.partial(irc_client.action.bind(irc_client), channel_name);\n\n    this.part = _.partial(irc_client.part.bind(irc_client), channel_name);\n    this.join = _.partial(irc_client.join.bind(irc_client), channel_name);\n    this.mode = _.partial(irc_client.mode.bind(irc_client), channel_name);\n    this.banlist = _.partial(irc_client.banlist.bind(irc_client), channel_name);\n    this.ban = _.partial(irc_client.ban.bind(irc_client), channel_name);\n    this.unban = _.partial(irc_client.unban.bind(irc_client), channel_name);\n    this.users = [];\n    irc_client.on('userlist', function (event) {\n      if (event.channel.toLowerCase() === _this.name.toLowerCase()) {\n        _this.users = event.users;\n      }\n    });\n    irc_client.on('join', function (event) {\n      if (event.channel === _this.name) {\n        _this.users.push(event);\n      }\n    });\n    irc_client.on('part', function (event) {\n      if (event.channel === _this.name) {\n        _this.users = _.filter(_this.users, function (o) {\n          return o.nick.toLowerCase() !== event.nick.toLowerCase();\n        });\n      }\n    });\n    irc_client.on('kick', function (event) {\n      if (event.channel === _this.name) {\n        _this.users = _.filter(_this.users, function (o) {\n          return o.nick.toLowerCase() !== event.kicked.toLowerCase();\n        });\n      }\n    });\n    irc_client.on('quit', function (event) {\n      _this.users = _.filter(_this.users, function (o) {\n        return o.nick.toLowerCase() !== event.nick.toLowerCase();\n      });\n    });\n    irc_client.on('nick', function (event) {\n      _.find(_this.users, function (o) {\n        if (o.nick.toLowerCase() === event.nick.toLowerCase()) {\n          o.nick = event.new_nick;\n          return true;\n        }\n      });\n    });\n    irc_client.on('mode', function (event) {\n      /* event will be something like:\n      {\n          target: '#prawnsalad',\n          nick: 'ChanServ',\n          modes: [ { mode: '+o', param: 'prawnsalad' } ],\n          time: undefined\n      }\n      */\n      if (event.target.toLowerCase() !== _this.name.toLowerCase()) {\n        return;\n      } // There can be multiple modes set at once, loop through\n\n\n      _.each(event.modes, function (mode) {\n        // If this mode has a user prefix then we need to update the user object\n        // eg. +o +h +v\n        var user_prefix = _.find(irc_client.network.options.PREFIX, {\n          mode: mode.mode[1]\n        });\n\n        if (!user_prefix) {// TODO : manage channel mode changes\n        } else {\n          // It's a user mode\n          // Find the user affected\n          var user = _.find(_this.users, function (u) {\n            return u.nick.toLowerCase() === mode.param.toLowerCase();\n          });\n\n          if (!user) {\n            return;\n          }\n\n          if (mode.mode[0] === '+') {\n            user.modes = user.modes || [];\n            user.modes.push(mode.mode[1]);\n          } else {\n            _.pull(user.modes, mode.mode[1]);\n          }\n        }\n      });\n    });\n    this.join(key);\n  }\n  /**\n   * Relay messages between this channel to another\n   * @param  {IrcChannel|String} target_chan Target channel\n   * @param  {Object} opts        Extra options\n   *\n   * opts may contain the following properties:\n   * one_way (false) Only relay messages to target_chan, not the reverse\n   * replay_nicks (true) Include the sending nick as part of the relayed message\n   */\n\n\n  _createClass(IrcChannel, [{\n    key: \"relay\",\n    value: function relay(target_chan, opts) {\n      opts = _.extend({\n        one_way: false,\n        replay_nicks: true\n      }, opts);\n\n      if (typeof target_chan === 'string') {\n        target_chan = this.irc_client.channel(target_chan);\n      }\n\n      var this_stream = this.stream(opts);\n      var other_stream = target_chan.stream(opts);\n      this_stream.pipe(other_stream);\n\n      if (!opts.one_way) {\n        other_stream.pipe(this_stream);\n      }\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(stream_opts) {\n      var _this2 = this;\n\n      var read_queue = [];\n      var is_reading = false;\n      var stream = new DuplexStream({\n        objectMode: true,\n        write: function write(chunk, encoding, next) {\n          // Support piping from one irc buffer to another\n          if (_typeof(chunk) === 'object' && typeof chunk.message === 'string') {\n            if (stream_opts.replay_nicks) {\n              chunk = '<' + chunk.nick + '> ' + chunk.message;\n            } else {\n              chunk = chunk.message;\n            }\n          }\n\n          _this2.say(chunk.toString());\n\n          next();\n        },\n        read: function read() {\n          is_reading = true;\n\n          while (read_queue.length > 0) {\n            var message = read_queue.shift();\n\n            if (stream.push(message) === false) {\n              is_reading = false;\n              break;\n            }\n          }\n        }\n      });\n      this.irc_client.on('privmsg', function (event) {\n        if (event.target.toLowerCase() === _this2.name.toLowerCase()) {\n          read_queue.push(event);\n\n          if (is_reading) {\n            stream._read();\n          }\n        }\n      });\n      return stream;\n    }\n  }, {\n    key: \"updateUsers\",\n    value: function updateUsers(cb) {\n      var _this3 = this;\n\n      var updateUserList = function updateUserList(event) {\n        if (event.channel.toLowerCase() === _this3.name.toLowerCase()) {\n          _this3.irc_client.removeListener('userlist', updateUserList);\n\n          if (typeof cb === 'function') {\n            cb(_this3);\n          }\n        }\n      };\n\n      this.irc_client.on('userlist', updateUserList);\n      this.irc_client.raw('NAMES', this.name);\n    }\n  }]);\n\n  return IrcChannel;\n}();\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/channel.js?");

/***/ }),

/***/ "./node_modules/irc-framework/dist/browser/src/client.js":
/*!***************************************************************!*\
  !*** ./node_modules/irc-framework/dist/browser/src/client.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol */ \"./node_modules/core-js/modules/es.symbol.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.description */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n\n__webpack_require__(/*! core-js/modules/es.symbol.iterator */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.concat */ \"./node_modules/core-js/modules/es.array.concat.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.filter */ \"./node_modules/core-js/modules/es.array.filter.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.find */ \"./node_modules/core-js/modules/es.array.find.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.for-each */ \"./node_modules/core-js/modules/es.array.for-each.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.from */ \"./node_modules/core-js/modules/es.array.from.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.index-of */ \"./node_modules/core-js/modules/es.array.index-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.is-array */ \"./node_modules/core-js/modules/es.array.is-array.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.join */ \"./node_modules/core-js/modules/es.array.join.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.slice */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.now */ \"./node_modules/core-js/modules/es.date.now.js\");\n\n__webpack_require__(/*! core-js/modules/es.date.to-string */ \"./node_modules/core-js/modules/es.date.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.bind */ \"./node_modules/core-js/modules/es.function.bind.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.name */ \"./node_modules/core-js/modules/es.function.name.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.create */ \"./node_modules/core-js/modules/es.object.create.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.define-property */ \"./node_modules/core-js/modules/es.object.define-property.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of */ \"./node_modules/core-js/modules/es.object.get-prototype-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.keys */ \"./node_modules/core-js/modules/es.object.keys.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ \"./node_modules/core-js/modules/es.object.set-prototype-of.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.to-string */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.reflect.construct */ \"./node_modules/core-js/modules/es.reflect.construct.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.to-string */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.match */ \"./node_modules/core-js/modules/es.string.match.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.split */ \"./node_modules/core-js/modules/es.string.split.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar _ = {\n  extend: __webpack_require__(/*! lodash/extend */ \"./node_modules/lodash/extend.js\"),\n  find: __webpack_require__(/*! lodash/find */ \"./node_modules/lodash/find.js\"),\n  each: __webpack_require__(/*! lodash/each */ \"./node_modules/lodash/each.js\"),\n  defer: __webpack_require__(/*! lodash/defer */ \"./node_modules/lodash/defer.js\"),\n  bind: __webpack_require__(/*! lodash/bind */ \"./node_modules/lodash/bind.js\")\n};\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n\nvar MiddlewareHandler = __webpack_require__(/*! middleware-handler */ \"./node_modules/middleware-handler/index.js\");\n\nvar IrcCommandHandler = __webpack_require__(/*! ./commands/ */ \"./node_modules/irc-framework/dist/browser/src/commands/index.js\").CommandHandler;\n\nvar IrcMessage = __webpack_require__(/*! ./ircmessage */ \"./node_modules/irc-framework/dist/browser/src/ircmessage.js\");\n\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/irc-framework/dist/browser/src/connection.js\");\n\nvar NetworkInfo = __webpack_require__(/*! ./networkinfo */ \"./node_modules/irc-framework/dist/browser/src/networkinfo.js\");\n\nvar User = __webpack_require__(/*! ./user */ \"./node_modules/irc-framework/dist/browser/src/user.js\");\n\nvar Channel = __webpack_require__(/*! ./channel */ \"./node_modules/irc-framework/dist/browser/src/channel.js\");\n\nvar _require = __webpack_require__(/*! ./linebreak */ \"./node_modules/irc-framework/dist/browser/src/linebreak.js\"),\n    lineBreak = _require.lineBreak;\n\nvar MessageTags = __webpack_require__(/*! ./messagetags */ \"./node_modules/irc-framework/dist/browser/src/messagetags.js\");\n\nvar default_transport = null;\n\nmodule.exports = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(IrcClient, _EventEmitter);\n\n  var _super = _createSuper(IrcClient);\n\n  function IrcClient(options) {\n    var _this;\n\n    _classCallCheck(this, IrcClient);\n\n    _this = _super.call(this);\n    _this.request_extra_caps = [];\n    _this.options = options || null;\n\n    _this.createStructure();\n\n    return _this;\n  }\n\n  _createClass(IrcClient, [{\n    key: \"_applyDefaultOptions\",\n    value: function _applyDefaultOptions(user_options) {\n      var defaults = {\n        nick: 'ircbot',\n        username: 'ircbot',\n        gecos: 'ircbot',\n        encoding: 'utf8',\n        version: 'node.js irc-framework',\n        enable_chghost: false,\n        enable_setname: false,\n        enable_echomessage: false,\n        auto_reconnect: true,\n        auto_reconnect_wait: 4000,\n        auto_reconnect_max_retries: 3,\n        ping_interval: 30,\n        ping_timeout: 120,\n        message_max_length: 350,\n        transport: default_transport\n      };\n      var props = Object.keys(defaults);\n\n      for (var i = 0; i < props.length; i++) {\n        if (typeof user_options[props[i]] === 'undefined') {\n          user_options[props[i]] = defaults[props[i]];\n        }\n      }\n\n      return user_options;\n    }\n  }, {\n    key: \"createStructure\",\n    value: function createStructure() {\n      var client = this; // Provides middleware hooks for either raw IRC commands or the easier to use parsed commands\n\n      client.raw_middleware = new MiddlewareHandler();\n      client.parsed_middleware = new MiddlewareHandler();\n      client.connection = new Connection(client.options);\n      client.network = new NetworkInfo();\n      client.user = new User();\n      client.command_handler = new IrcCommandHandler(client.connection, client.network);\n      client.addCommandHandlerListeners(); // Proxy some connection events onto this client\n\n      ['connecting', 'reconnecting', 'close', 'socket close', 'socket error', 'raw socket connected', 'debug', 'raw'].forEach(function (event_name) {\n        client.connection.on(event_name, function () {\n          var args = Array.prototype.slice.call(arguments);\n          client.emit.apply(client, [event_name].concat(args));\n        });\n      });\n      client.connection.on('socket connected', function () {\n        client.emit('socket connected');\n        client.registerToNetwork();\n        client.startPeriodicPing();\n      });\n      client.connection.on('connecting', function () {\n        // Reset cap negotiation on a new connection\n        // This prevents stale state if a connection gets closed during CAP negotiation\n        client.network.cap.negotiating = false;\n        client.network.cap.requested = [];\n        client.command_handler.resetCache();\n      }); // IRC command routing\n\n      client.connection.on('message', function (message, raw_line) {\n        client.raw_middleware.handle([message.command, message, raw_line, client], function (err) {\n          if (err) {\n            console.log(err.stack);\n            return;\n          }\n\n          client.command_handler.dispatch(message);\n        });\n      });\n      client.on('away', function (event) {\n        if (event.nick.toLowerCase() === client.user.nick.toLowerCase()) {\n          client.user.away = true;\n        }\n      });\n      client.on('back', function (event) {\n        if (event.nick.toLowerCase() === client.user.nick.toLowerCase()) {\n          client.user.away = false;\n        }\n      }); // Proxy the command handler events onto the client object, with some added sugar\n\n      client.proxyIrcEvents();\n      Object.defineProperty(client, 'connected', {\n        enumerable: true,\n        get: function get() {\n          return client.connection && client.connection.connected;\n        }\n      });\n    }\n  }, {\n    key: \"requestCap\",\n    value: function requestCap(cap) {\n      this.request_extra_caps = this.request_extra_caps.concat(cap);\n    }\n  }, {\n    key: \"use\",\n    value: function use(middleware_fn) {\n      middleware_fn(this, this.raw_middleware, this.parsed_middleware);\n      return this;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options) {\n      var client = this; // Use the previous options object if we're calling .connect() again\n\n      if (!options && !client.options) {\n        throw new Error('Options object missing from IrcClient.connect()');\n      } else if (!options) {\n        options = client.options;\n      } else {\n        client.options = options;\n      }\n\n      client._applyDefaultOptions(options);\n\n      if (client.connection && client.connection.connected) {\n        client.debugOut('connect() called when already connected');\n        client.connection.end();\n      }\n\n      client.user.nick = options.nick;\n      client.user.username = options.username;\n      client.user.gecos = options.gecos;\n      client.command_handler.requestExtraCaps(client.request_extra_caps); // Everything is setup and prepared, start connecting\n\n      client.connection.connect(options);\n    } // Proxy the command handler events onto the client object, with some added sugar\n    // Events are handled in order:\n    // 1. Received from the command handler\n    // 2. Checked if any extra properties/methods are to be added to the event + re-emitted\n    // 3. Routed through middleware\n    // 4. Emitted from the client instance\n\n  }, {\n    key: \"proxyIrcEvents\",\n    value: function proxyIrcEvents() {\n      var client = this;\n      this.command_handler.on('all', function (event_name, event_arg) {\n        client.resetPingTimeoutTimer(); // Add a reply() function to selected message events\n\n        if (['privmsg', 'notice', 'action'].indexOf(event_name) > -1) {\n          event_arg.reply = function (message) {\n            var dest = event_arg.target === client.user.nick ? event_arg.nick : event_arg.target;\n            client.say(dest, message);\n          }; // These events with .reply() function are all messages. Emit it separately\n          // TODO: Should this consider a notice a message?\n\n\n          client.command_handler.emit('message', _.extend({\n            type: event_name\n          }, event_arg));\n        }\n\n        client.parsed_middleware.handle([event_name, event_arg, client], function (err) {\n          if (err) {\n            console.error(err.stack);\n            return;\n          }\n\n          client.emit(event_name, event_arg);\n        });\n      });\n    }\n  }, {\n    key: \"addCommandHandlerListeners\",\n    value: function addCommandHandlerListeners() {\n      var client = this;\n      var commands = this.command_handler;\n      commands.on('nick', function (event) {\n        if (client.user.nick === event.nick) {\n          // nicks starting with numbers are reserved for uuids\n          // we dont want to store these as they cannot be used\n          if (event.new_nick.match(/^\\d/)) {\n            return;\n          }\n\n          client.user.nick = event.new_nick;\n        }\n      });\n      commands.on('mode', function (event) {\n        if (client.user.nick === event.target) {\n          event.modes.forEach(function (mode) {\n            client.user.toggleModes(mode.mode);\n          });\n        }\n      });\n      commands.on('wholist', function (event) {\n        var thisUser = _.find(event.users, {\n          nick: client.user.nick\n        });\n\n        if (thisUser) {\n          client.user.username = thisUser.ident;\n          client.user.host = thisUser.hostname;\n        }\n      });\n      commands.on('registered', function (event) {\n        client.user.nick = event.nick;\n        client.connection.registeredSuccessfully();\n        client.emit('connected', event);\n      });\n      commands.on('displayed host', function (event) {\n        if (client.user.nick === event.nick) {\n          client.user.host = event.host;\n        }\n      }); // Don't let IRC ERROR command kill the node.js process if unhandled\n\n      commands.on('error', function (event) {});\n    }\n  }, {\n    key: \"registerToNetwork\",\n    value: function registerToNetwork() {\n      var webirc = this.options.webirc;\n\n      if (webirc) {\n        var address = String(webirc.address); // Prepend a zero to addresses that begin with colon (like ::1)\n        // as colon is using to denote last argument in IRC\n\n        if (address[0] === ':') {\n          address = '0' + address;\n        }\n\n        this.raw('WEBIRC', webirc.password, webirc.username, webirc.hostname, address, MessageTags.encode(webirc.options || {}, ' '));\n      }\n\n      this.raw('CAP LS 302');\n\n      if (this.options.password) {\n        this.raw('PASS', this.options.password);\n      }\n\n      this.raw('NICK', this.user.nick);\n      this.raw('USER', this.options.username, 0, '*', this.user.gecos);\n    }\n  }, {\n    key: \"startPeriodicPing\",\n    value: function startPeriodicPing() {\n      var that = this;\n      var timeout_timer = null;\n\n      if (that.options.ping_interval <= 0 || that.options.ping_timeout <= 0) {\n        return;\n      } // Constantly ping the server for lag and time syncing functions\n\n\n      function pingServer() {\n        that.ping();\n        that.connection.setTimeout(pingServer, that.options.ping_interval * 1000);\n      } // Data from the server was detected so restart the timeout\n\n\n      function resetPingTimeoutTimer() {\n        that.connection.clearTimeout(timeout_timer);\n        timeout_timer = that.connection.setTimeout(pingTimeout, that.options.ping_timeout * 1000);\n      }\n\n      function pingTimeout() {\n        that.debugOut('Ping timeout (' + that.options.ping_timeout + ' seconds)');\n        that.emit('ping timeout');\n        var end_msg = that.rawString('QUIT', 'Ping timeout (' + that.options.ping_timeout + ' seconds)');\n        that.connection.end(end_msg, true);\n      }\n\n      this.resetPingTimeoutTimer = resetPingTimeoutTimer;\n      that.connection.setTimeout(pingServer, that.options.ping_interval * 1000);\n    } // Gets overridden with a function in startPeriodicPing(). Only set here for completeness.\n\n  }, {\n    key: \"resetPingTimeoutTimer\",\n    value: function resetPingTimeoutTimer() {}\n  }, {\n    key: \"debugOut\",\n    value: function debugOut(out) {\n      this.emit('debug', 'Client ' + out);\n    }\n    /**\n     * Client API\n     */\n\n  }, {\n    key: \"raw\",\n    value: function raw(input) {\n      if (input instanceof IrcMessage) {\n        this.connection.write(input.to1459());\n      } else {\n        this.connection.write(this.rawString.apply(this, arguments));\n      }\n    }\n  }, {\n    key: \"rawString\",\n    value: function rawString(input) {\n      var args;\n\n      if (input.constructor === Array) {\n        args = input;\n      } else {\n        args = Array.prototype.slice.call(arguments, 0);\n      }\n\n      args = args.filter(function (item) {\n        return typeof item === 'number' || typeof item === 'string';\n      });\n\n      if (args.length > 1 && args[args.length - 1].match(/^:|\\s/)) {\n        args[args.length - 1] = ':' + args[args.length - 1];\n      }\n\n      return args.join(' ');\n    }\n  }, {\n    key: \"quit\",\n    value: function quit(message) {\n      this.connection.end(this.rawString('QUIT', message));\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(message) {\n      this.raw('PING', message || 'kiwitime-' + Date.now());\n    }\n  }, {\n    key: \"changeNick\",\n    value: function changeNick(nick) {\n      this.raw('NICK', nick);\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(commandName, target, message) {\n      var _this2 = this;\n\n      var lines = message.split(/\\r\\n|\\n|\\r/).filter(function (i) {\n        return i;\n      });\n      lines.forEach(function (line) {\n        // Maximum length of target + message we can send to the IRC server is 500 characters\n        // but we need to leave extra room for the sender prefix so the entire message can\n        // be sent from the IRCd to the target without being truncated.\n        var blocks = _toConsumableArray(lineBreak(line, {\n          bytes: _this2.options.message_max_length,\n          allowBreakingWords: true,\n          allowBreakingGraphemes: true\n        }));\n\n        blocks.forEach(function (block) {\n          return _this2.raw(commandName, target, block);\n        });\n      });\n    }\n  }, {\n    key: \"say\",\n    value: function say(target, message) {\n      return this.sendMessage('PRIVMSG', target, message);\n    }\n  }, {\n    key: \"notice\",\n    value: function notice(target, message) {\n      return this.sendMessage('NOTICE', target, message);\n    }\n  }, {\n    key: \"tagmsg\",\n    value: function tagmsg(target) {\n      var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var msg = new IrcMessage('TAGMSG', target);\n      msg.tags = tags;\n      this.raw(msg);\n    }\n  }, {\n    key: \"join\",\n    value: function join(channel, key) {\n      var raw = ['JOIN', channel];\n\n      if (key) {\n        raw.push(key);\n      }\n\n      this.raw(raw);\n    }\n  }, {\n    key: \"part\",\n    value: function part(channel, message) {\n      var raw = ['PART', channel];\n\n      if (message) {\n        raw.push(message);\n      }\n\n      this.raw(raw);\n    }\n  }, {\n    key: \"mode\",\n    value: function mode(channel, _mode, extra_args) {\n      var raw = ['MODE', channel, _mode];\n\n      if (extra_args) {\n        if (Array.isArray(extra_args)) {\n          raw = raw.concat(extra_args);\n        } else {\n          raw.push(extra_args);\n        }\n      }\n\n      this.raw(raw);\n    }\n  }, {\n    key: \"inviteList\",\n    value: function inviteList(channel, cb) {\n      var client = this;\n      var invex = this.network.supports('INVEX');\n      var mode = 'I';\n\n      if (typeof invex === 'string' && invex) {\n        mode = invex;\n      }\n\n      function onInviteList(event) {\n        if (event.channel.toLowerCase() === channel.toLowerCase()) {\n          unbindEvents();\n\n          if (typeof cb === 'function') {\n            cb(event);\n          }\n        }\n      }\n\n      function onInviteListErr(event) {\n        if (event.error === 'chanop_privs_needed') {\n          unbindEvents();\n\n          if (typeof cb === 'function') {\n            cb(null);\n          }\n        }\n      }\n\n      function bindEvents() {\n        client.on('inviteList', onInviteList);\n        client.on('irc error', onInviteListErr);\n      }\n\n      function unbindEvents() {\n        client.removeListener('inviteList', onInviteList);\n        client.removeListener('irc error', onInviteListErr);\n      }\n\n      bindEvents();\n      this.raw(['MODE', channel, mode]);\n    }\n  }, {\n    key: \"invite\",\n    value: function invite(channel, nick) {\n      var raw = ['INVITE', nick, channel];\n      this.raw(raw);\n    }\n  }, {\n    key: \"addInvite\",\n    value: function addInvite(channel, mask) {\n      var mode = 'I';\n      var invex = this.network.supports('INVEX');\n\n      if (typeof invex === 'string') {\n        mode = invex;\n      }\n\n      var raw = ['MODE', channel, '+' + mode, mask];\n      this.raw(raw);\n    }\n  }, {\n    key: \"removeInvite\",\n    value: function removeInvite(channel, mask) {\n      var mode = 'I';\n      var invex = this.network.supports('INVEX');\n\n      if (typeof invex === 'string') {\n        mode = invex;\n      }\n\n      var raw = ['MODE', channel, '-' + mode, mask];\n      this.raw(raw);\n    }\n  }, {\n    key: \"banlist\",\n    value: function banlist(channel, cb) {\n      var client = this;\n      var raw = ['MODE', channel, 'b'];\n      this.on('banlist', function onBanlist(event) {\n        if (event.channel.toLowerCase() === channel.toLowerCase()) {\n          client.removeListener('banlist', onBanlist);\n\n          if (typeof cb === 'function') {\n            cb(event);\n          }\n        }\n      });\n      this.raw(raw);\n    }\n  }, {\n    key: \"ban\",\n    value: function ban(channel, mask) {\n      var raw = ['MODE', channel, '+b', mask];\n      this.raw(raw);\n    }\n  }, {\n    key: \"unban\",\n    value: function unban(channel, mask) {\n      var raw = ['MODE', channel, '-b', mask];\n      this.raw(raw);\n    }\n  }, {\n    key: \"setTopic\",\n    value: function setTopic(channel, newTopic) {\n      this.raw('TOPIC', channel, newTopic);\n    }\n  }, {\n    key: \"ctcpRequest\",\n    value: function ctcpRequest(target, type\n    /*, paramN */\n    ) {\n      var params = Array.prototype.slice.call(arguments, 1); // make sure the CTCP type is uppercased\n\n      params[0] = params[0].toUpperCase();\n      this.raw('PRIVMSG', target, String.fromCharCode(1) + params.join(' ') + String.fromCharCode(1));\n    }\n  }, {\n    key: \"ctcpResponse\",\n    value: function ctcpResponse(target, type\n    /*, paramN */\n    ) {\n      var params = Array.prototype.slice.call(arguments, 1); // make sure the CTCP type is uppercased\n\n      params[0] = params[0].toUpperCase();\n      this.raw('NOTICE', target, String.fromCharCode(1) + params.join(' ') + String.fromCharCode(1));\n    }\n  }, {\n    key: \"action\",\n    value: function action(target, message) {\n      var that = this; // Maximum length of target + message we can send to the IRC server is 500 characters\n      // but we need to leave extra room for the sender prefix so the entire message can\n      // be sent from the IRCd to the target without being truncated.\n      // The block length here is the max, but without the non-content characters:\n      // the command name, the space, and the two SOH chars\n\n      var commandName = 'ACTION';\n      var blockLength = this.options.message_max_length - (commandName.length + 3);\n\n      var blocks = _toConsumableArray(lineBreak(message, {\n        bytes: blockLength,\n        allowBreakingWords: true,\n        allowBreakingGraphemes: true\n      }));\n\n      blocks.forEach(function (block) {\n        that.ctcpRequest(target, commandName, block);\n      });\n      return blocks;\n    }\n  }, {\n    key: \"whois\",\n    value: function whois(target, _cb) {\n      var client = this;\n      var cb;\n      var irc_args = ['WHOIS']; // Support whois(target, arg1, arg2, argN, cb)\n\n      _.each(arguments, function (arg) {\n        if (typeof arg === 'function') {\n          cb = arg;\n        } else {\n          irc_args.push(arg);\n        }\n      });\n\n      this.on('whois', function onWhois(event) {\n        if (event.nick.toLowerCase() === target.toLowerCase()) {\n          client.removeListener('whois', onWhois);\n\n          if (typeof cb === 'function') {\n            cb(event);\n          }\n        }\n      });\n      this.raw(irc_args);\n    }\n  }, {\n    key: \"whowas\",\n    value: function whowas(target, _cb) {\n      var client = this;\n      var cb;\n      var irc_args = ['WHOWAS']; // Support whowas(target, arg1, arg2, argN, cb)\n\n      _.each(arguments, function (arg) {\n        if (typeof arg === 'function') {\n          cb = arg;\n        } else {\n          irc_args.push(arg);\n        }\n      });\n\n      this.on('whowas', function onWhowas(event) {\n        if (event.nick.toLowerCase() === target.toLowerCase()) {\n          client.removeListener('whowas', onWhowas);\n\n          if (typeof cb === 'function') {\n            cb(event);\n          }\n        }\n      });\n      this.raw(irc_args);\n    }\n    /**\n     * WHO requests are queued up to run serially.\n     * This is mostly because networks will only reply serially and it makes\n     * it easier to include the correct replies to callbacks\n     */\n\n  }, {\n    key: \"who\",\n    value: function who(target, cb) {\n      if (!this.who_queue) {\n        this.who_queue = [];\n      }\n\n      this.who_queue.push([target, cb]);\n      this.processNextWhoQueue();\n    }\n  }, {\n    key: \"processNextWhoQueue\",\n    value: function processNextWhoQueue() {\n      var client = this; // No items in the queue or the queue is already running?\n\n      if (client.who_queue.length === 0 || client.who_queue.is_running) {\n        return;\n      }\n\n      client.who_queue.is_running = true;\n      var this_who = client.who_queue.shift();\n      var target = this_who[0];\n      var cb = this_who[1];\n\n      if (!target || typeof target !== 'string') {\n        if (typeof cb === 'function') {\n          _.defer(cb, {\n            target: target,\n            users: []\n          });\n        } // Start the next queued WHO request\n\n\n        client.who_queue.is_running = false;\n\n        _.defer(_.bind(client.processNextWhoQueue, client));\n\n        return;\n      }\n\n      client.on('wholist', function onWho(event) {\n        client.removeListener('wholist', onWho); // Start the next queued WHO request\n\n        client.who_queue.is_running = false;\n\n        _.defer(_.bind(client.processNextWhoQueue, client));\n\n        if (typeof cb === 'function') {\n          cb({\n            target: target,\n            users: event.users\n          });\n        }\n      });\n\n      if (client.network.supports('whox')) {\n        client.raw('WHO', target, '%cuhsnfdaor');\n      } else {\n        client.raw('WHO', target);\n      }\n    }\n    /**\n     * Explicitely start a channel list, avoiding potential issues with broken IRC servers not sending RPL_LISTSTART\n     */\n\n  }, {\n    key: \"list\",\n    value: function list()\n    /* paramN */\n    {\n      var args = Array.prototype.slice.call(arguments);\n      this.command_handler.cache('chanlist').channels = [];\n      args.unshift('LIST');\n      this.raw(args);\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(channel_name) {\n      return new Channel(this, channel_name);\n    }\n  }, {\n    key: \"match\",\n    value: function match(match_regex, cb, message_type) {\n      var client = this;\n\n      var onMessage = function onMessage(event) {\n        if (event.message.match(match_regex)) {\n          cb(event);\n        }\n      };\n\n      this.on(message_type || 'message', onMessage);\n      return {\n        stop: function stop() {\n          client.removeListener(message_type || 'message', onMessage);\n        }\n      };\n    }\n  }, {\n    key: \"matchNotice\",\n    value: function matchNotice(match_regex, cb) {\n      return this.match(match_regex, cb, 'notice');\n    }\n  }, {\n    key: \"matchMessage\",\n    value: function matchMessage(match_regex, cb) {\n      return this.match(match_regex, cb, 'privmsg');\n    }\n  }, {\n    key: \"matchAction\",\n    value: function matchAction(match_regex, cb) {\n      return this.match(match_regex, cb, 'action');\n    }\n  }, {\n    key: \"Message\",\n    get: function get() {\n      return IrcMessage;\n    }\n  }], [{\n    key: \"setDefaultTransport\",\n    value: function setDefaultTransport(transport) {\n      default_transport = transport;\n    }\n  }]);\n\n  return IrcClient;\n}(EventEmitter);\n\n//# sourceURL=webpack://pesterchum/./node_modules/irc-framework/dist/browser/src/client.js?");

/***/ })

}]);